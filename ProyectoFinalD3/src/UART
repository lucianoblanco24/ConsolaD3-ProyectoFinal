#include "LPC17xx.h"
#include "LPC17xx_gpio.h"
#include "LPC17xx_pinsel.h"
#include "LPC17xx_uart.h"

#define OUTPUT (uint8_t)1
#define INPUT  (uint8_t)0
#define PIN_22 (1U << 22)
#define PORT_0 0

void cfgGPIO(void);
void cfgUART(void);

int main(void)
{
    cfgGPIO();
    cfgUART();

    // Mensaje inicial para verificar conexión
    UART_Send((LPC_UART_TypeDef *)LPC_UART0, (uint8_t *)"UART0 OK\r\n", 10, BLOCKING);


    while (1)
    {}
}

void cfgGPIO(void)
{
    PINSEL_CFG_Type cfgPinLED, cfgPinRXD0, cfgPinTXD0;

    // --- LED en P0.22 ---
    cfgPinLED.Portnum   = PINSEL_PORT_0;
    cfgPinLED.Pinnum    = PINSEL_PIN_22;
    cfgPinLED.Funcnum   = PINSEL_FUNC_0;
    cfgPinLED.Pinmode   = PINSEL_PINMODE_PULLUP;
    cfgPinLED.OpenDrain = PINSEL_PINMODE_NORMAL;
    PINSEL_ConfigPin(&cfgPinLED);

    // --- RXD0 (P0.3) ---
    cfgPinRXD0.Portnum   = PINSEL_PORT_0;
    cfgPinRXD0.Pinnum    = PINSEL_PIN_3;
    cfgPinRXD0.Funcnum   = PINSEL_FUNC_1;
    cfgPinRXD0.Pinmode   = PINSEL_PINMODE_PULLUP;
    cfgPinRXD0.OpenDrain = PINSEL_PINMODE_NORMAL;
    PINSEL_ConfigPin(&cfgPinRXD0);

    // --- TXD0 (P0.2) ---
    cfgPinTXD0.Portnum   = PINSEL_PORT_0;
    cfgPinTXD0.Pinnum    = PINSEL_PIN_2;
    cfgPinTXD0.Funcnum   = PINSEL_FUNC_1;
    cfgPinTXD0.Pinmode   = PINSEL_PINMODE_PULLUP;
    cfgPinTXD0.OpenDrain = PINSEL_PINMODE_NORMAL;
    PINSEL_ConfigPin(&cfgPinTXD0);

    // Configurar LED como salida y encenderlo (activo por bajo)
    GPIO_SetDir(PORT_0, PIN_22, OUTPUT);
    GPIO_SetValue(PORT_0, PIN_22);
}
void cfgUART(void)
{
	LPC_SC->PCONP |= (1 << 3);

    UART_CFG_Type cfgUART0;
    UART_FIFO_CFG_Type cfgUART0FIFO;

    UART_ConfigStructInit(&cfgUART0);
    cfgUART0.Baud_rate = 115200;

    UART_Init((LPC_UART_TypeDef *)LPC_UART0, &cfgUART0);
    UART_FIFOConfigStructInit(&cfgUART0FIFO);
    UART_FIFOConfig((LPC_UART_TypeDef *)LPC_UART0, &cfgUART0FIFO);
    UART_IntConfig((LPC_UART_TypeDef *)LPC_UART0, UART_INTCFG_RBR, ENABLE); // Habilita interrupción por "Receive Data Ready"
    UART_TxCmd((LPC_UART_TypeDef *)LPC_UART0, ENABLE);

    NVIC_EnableIRQ(UART0_IRQn);
}
void UART0_IRQHandler(void)
{
    uint8_t receivedData;
    uint32_t iir_value;

    // Leemos el registro de identificación de interrupción para saber qué la causó
    iir_value = UART_GetIntId((LPC_UART_TypeDef *)LPC_UART0);

    // Verificamos si la interrupción fue por "Receive Data Ready" (RDA)
    if ((iir_value & UART_IIR_INTID_RDA) || (iir_value & UART_IIR_INTID_CTI))
    {
        receivedData = UART_ReceiveByte((LPC_UART_TypeDef *)LPC_UART0);

        UART_SendByte((LPC_UART_TypeDef *)LPC_UART0, receivedData);

        if (receivedData == '1')
        {
            GPIO_ClearValue(PORT_0, PIN_22); // LED encendido (activo por bajo)
        }
        else
        {
            GPIO_SetValue(PORT_0, PIN_22);   // LED apagado
        }
    }
}
